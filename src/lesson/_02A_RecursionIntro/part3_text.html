<!DOCTYPE html>
<html>
<head>
  <title>Treść zadania</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <style type="text/css">
    body {
      font-size: 14px;
    }
    img {
      margin-right: 3px;
      float: left;
    }
    h2 {
      margin-top: 0px;
      margin-bottom: 0px;
      text-align: center;
    }
    div {
      margin-top: 15px;
      margin-bottom: 0px;
    }
    div.first {
      margin-top: 5px;
    }
    div.clear {
      margin-top: 0px;
      clear: both;
    }
    code {
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <h2>Przepełnienie stosu i warunek stopu</h2>
  <div class="first">
    Rekurencyjna funkcja silnia wywołuje się dla coraz mniejszych liczb, 
    aż dojdzie do wywołania funkcji silna z argumentem zero.  
    Wówczas program od razu zwraca wynik, a następnie poprzednie wywołania 
    funkcji wykonują mnożenie, zwracają wynik i także kończą swoje działanie.
  </div>
  
  <div>
    Zastanów się teraz co by się stało jeśli byśmy usunęli z kodu linijkę: „<code>if (n<=1) return 1;</code>”.
    Wówczas program wyglądałby tak:<br />
    <code>
      int silnia(n)<br />
      {<br />
      &nbsp;&nbsp;return n * silnia(n-1);<br />
      }<br />
    </code>
  </div>

  <div>
    Uruchom program dla tak zmodyfikowanej funkcji silnia. Wywołaj funkcję dla liczby pięć, 
    następnie krok po kroku analizuj działanie programu, kiedy na stosie będzie dziesięć instancji, 
    naciśnij przycisk „szybkie wykonanie programu” (alt+F5) i zobacz co się stanie.
  </div>

  <div>
    Uruchomiony program wywołuje funkcję dla coraz mniejszych liczb, jednak teraz funkcja 
    wywołuje się także dla liczb ujemnych. W teorii funkcja silnia mogła by się 
    wywoływać bez końca (w końcu ujemnych liczb naturalnych jest nieskończenie wiele). 
    W praktyce jednak takiej możliwości nie ma. Program odkłada na stosie kolejne rekordy aktywacji. 
    Jak wiemy wywołania funkcji zajmują miejsca w pamięci komputer, 
    wiemy również, że pamięć komputera jest ograniczona. Wobec tego kiedyś musi dojść do tego momentu, 
    iż na nowy rekord aktywacji zabraknie miejsca. Ten moment nazywa się przepełnieniem stosu (ang. stackoverflow). 
    Jest on częstym błędem występujących w programach młodych programistów. 
    W systemie rekurencja wielkość stosu została ograniczona do stu wywołań funkcji.
  </div>

  <div>
    Z powyższych obserwacji wynika, iż funkcja rekurencyjna nie może być wywoływana bez końca. 
    W funkcji musi znaleźć odpowiedni fragment kodu, który będzie odpowiedzialny 
    za zatrzymywanie się wywoływania rekurencji. Ten fragment kodu nazywa się warunkiem stopu. 
    W przypadku funkcji silnia była to linijka „<code>if (n<=1) return 1;</code>”. 
    Zapamiętaj, że poprawnie napisana funkcja rekurencyjna powinna się 
    zawsze zatrzymywać dla wszystkich danych uwzględnionych w specyfikacji.
  </div>

</body>
</html> 